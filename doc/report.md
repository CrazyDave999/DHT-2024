# 关于DHT

分布式哈希表（Distributed Hash Table）是去中心化的分布式系统，用于存储和检索在节点之间分布的键值对。DHT通常用于分布式文件系统、对等网络（P2P）和去中心化应用程序中，以提供高效的查找和数据存储机制。DHT的核心特点是：

- **去中心化**：没有中心节点，所有节点地位相等地参与数据存储和查找。
- **可扩展性**：可以动态地加入或移除节点，网络规模可以线性地扩展，而不必担心节点太多导致系统过载。
- **容错性**：节点失效时，数据可以在其他节点上恢复，这是相对于中心式服务器的重要优势。
- **高效查找**：查找、存储的时间复杂度可以做到 O(log N)。

# Chord 协议报告

## 核心思想

- **环形结构**：将 $[0, 2^{m}-1]$ 的整个地址空间映射到环上，实现ID的均匀分散。利用`finger_table`在当前节点与目标节点之间快速跳跃，保证对数级别的时间复杂度。对每个节点维护一个`predecessor`和一个`successor_list`，来保持稳定的环装结构。
- **备份**：分布式系统的容错性体现在少数节点异常退出后，仍可以从其他节点找回这些数据，这就需要将数据的备份`backup`同时存储在它的后继上，同时在前后节点状态发生改变时对应地对备份进行调整。
- **stabilize操作**：周期性地检查和修正节点之间的指针，保持网络的一致性和正确性。

## 实现细节

- 进行区间判断时，需要注意跨越零点的特殊情况，这时区间左端点的哈希值比右端的大。也需要注意端点重合的问题，如果对端点重合的情况没有谨慎处理可能导致死循环。
- stabilize操作中，需要检测新加入节点和节点下线两种情况，在两种情况下都要对环状结构和数据备份两方面分别进行维护。
  + 对于结构，可以在`successor_list`能找到一个在线的后继时，将对方的`successor_list`的后面部分拷贝到自身，这样环上节点互相拷贝多次后，就可以在几次stabilize操作后迅速更正各自的`successor_list`。此外，需要及时地保证`finger_table[0]`，即`successor`的正确性，否则在`find_closest_finger`函数中由于各个`finger`均不是最新的，将总是返回节点自身而造成死循环。
  + 对于数据，可以考虑在前驱更新时维护，也可以在后继更新时维护。这里为了一致性，我统一采用了在后继时维护。函数编写时应注意分成几个step，合理地排布数据维护各个阶段的顺序，并谨慎进行读写锁的获取。

# Kademlia协议报告

Kademlia协议中开始对文件进行分块，文件结构如下：

```
Kademlia
├── node.go
├── routingTable.go
└── utils.go
```

其中`node.go`为Kademlia算法主体逻辑，`routingTable`中实现了K-桶类`Bucket`及路由表类`RoutingTable`，`utils.go`中则主要实现了`NodeLookup`操作的辅助类`ShortList`。

## 核心思想

- **XOR度量空间**：将160bit的地址空间视为一棵0-1Trie，这就可以把每个节点视为树的一片叶子。点与点之间的距离使用XOR来进行运算。
- **k-buckets**：对于一个节点，将整棵树的剩余部分按照与自身的距离剖分成m个k-桶。在`FindNode`操作中优先查找离目标最近的桶，来保证算法的复杂度和收敛性。形象地，如果将一个k-桶视为表中的一行，那么这m行就构成了该节点知道的所有在线节点的信息，即它的路由表。

## 实现细节

- 对于桶的维护，需要在每次确定一个节点的在线信息时，对自己路由表中对应的桶进行`Update`操作。但是由于`Republish`等操作带来的并发访问量太大，如果在`Update`函数中分段加锁，可能导Segmentation Fault异常，于是直接对整个函数加锁。
- **ShortList**：作为`NodeLookup`操作的辅助类，是利用标准库中的`list`实现的一个简易的类似优先级队列的数据结构。将节点更新、取$\alpha$个最近的未被访问过的节点等操作封装为自身的方法。实现上最初考虑将`list`的迭代器`*list.Element`直接传出来进行节点状态的修改，但这会导致内部状态的非法改变而导致出错。最后还是考虑将节点内容取出，用切片返回。
- **Piggy-back**：论文中提到在任何的RPC方法完成后，理论上我们都获得了目标节点的在线情况，因此我们不能浪费这个信息，而需要据此及时更新自己的k-桶。实现上，可以将这个步骤包装进`RemoteCall`中，避免重复调用。另外也需要一个`Notify`操作，将自己的ip信息传递给对方，来告诉对方自己也是在线的。否则可能导致部分节点的路由表中始终只有少数几个点的情况。实现上也将`Notify`操作作为一个额外的RPC包装进`RemoteCall`中。这样虽然代码简单，但带来了重复的RPC调用，使得节点TCP负载增加。事实上也可以考虑在RPC方法的参数中包装自身的ip地址。
- **并发与递归**：在`NodeLookup`，`Republish`等操作中由于各个查找过程相互独立，因此考虑在递归的每一轮中并发地查找，并在一轮的末尾进行同步与状态更新。并发极大地提升效率，但也给网络带来更大的负载。因此需要合理地调整k值等参数，并给每个操作设置一个最大超时时间，从而避免造成网络的拥堵。
